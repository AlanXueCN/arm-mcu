diff -u newlib/libc/time.original/asctime_r.c newlib/libc/time/asctime_r.c
--- newlib/libc/time.original/asctime_r.c	2000-05-10 19:58:29.000000000 +0200
+++ newlib/libc/time/asctime_r.c	2011-05-23 13:17:06.000000000 +0200
@@ -18,7 +18,7 @@
 	"Jul", "Aug", "Sep", "Oct", "Nov", "Dec"
   };
 
-  sprintf (result, "%.3s %.3s%3d %.2d:%.2d:%.2d %d\n",
+  siprintf (result, "%.3s %.3s%3d %.2d:%.2d:%.2d %d\n",
 	   day_name[tim_p->tm_wday], 
 	   mon_name[tim_p->tm_mon],
 	   tim_p->tm_mday, tim_p->tm_hour, tim_p->tm_min,
diff -u newlib/libc/time.original/strftime.c newlib/libc/time/strftime.c
--- newlib/libc/time.original/strftime.c	2010-04-28 11:59:37.000000000 +0200
+++ newlib/libc/time/strftime.c	2011-05-23 13:29:35.000000000 +0200
@@ -283,6 +283,7 @@
 #if !defined(MAKE_WCSFTIME)
 #  define CHAR		char		/* string type basis */
 #  define CQ(a)		a		/* character constant qualifier */
+#  define snprintf	sniprintf
 #  define SFLG				/* %s flag (null for normal char) */
 #  define _ctloc(x) (ctloclen = strlen (ctloc = _CurrentTimeLocale->x), ctloc)
 #  define TOLOWER(c)	tolower((int)(unsigned char)(c))
@@ -1686,24 +1687,24 @@
 /* Set timezone so that %z and %Z tests come out right */
 cp = TZ;
 if((i=putenv(cp)))  {
-    printf( "putenv(%s) FAILED, ret %d\n", cp, i);
+    iprintf( "putenv(%s) FAILED, ret %d\n", cp, i);
     return(-1);
     }
 if(strcmp(getenv("TZ"),strchr(TZ,'=')+1))  {
-    printf( "TZ not set properly in environment\n");
+    iprintf( "TZ not set properly in environment\n");
     return(-2);
     }
 tzset();
  
 #if defined(VERBOSE)
-printf("_timezone=%d, _daylight=%d, _tzname[0]=%s, _tzname[1]=%s\n", _timezone, _daylight, _tzname[0], _tzname[1]);
+iprintf("_timezone=%d, _daylight=%d, _tzname[0]=%s, _tzname[1]=%s\n", _timezone, _daylight, _tzname[0], _tzname[1]);
 {
 long offset;
 __tzinfo_type *tz = __gettzinfo ();
 /* The sign of this is exactly opposite the envvar TZ.  We
    could directly use the global _timezone for tm_isdst==0,
    but have to use __tzrule for daylight savings.  */
-printf("tz->__tzrule[0].offset=%d, tz->__tzrule[1].offset=%d\n", tz->__tzrule[0].offset, tz->__tzrule[1].offset);
+iprintf("tz->__tzrule[0].offset=%d, tz->__tzrule[1].offset=%d\n", tz->__tzrule[0].offset, tz->__tzrule[1].offset);
 }
 #endif
  
@@ -1715,13 +1716,13 @@
 	ret = strftime(out, test->vec[i].max, test->vec[i].fmt, test->tms);
 	if(ret != test->vec[i].ret)  {
 	    errr++;
-	    fprintf(stderr,
+	    fiprintf(stderr,
 		"ERROR:  return %d != %d expected for List[%d].vec[%d]\n",
 						ret, test->vec[i].ret, l, i);
 	    }
 	if(strncmp(out, test->vec[i].out, test->vec[i].max-1))  {
 	    erro++;
-	    fprintf(stderr,
+	    fiprintf(stderr,
 		"ERROR:  \"%"SFLG"s\" != \"%"SFLG"s\" expected for List[%d].vec[%d]\n",
 						out, test->vec[i].out, l, i);
 	    }
@@ -1737,7 +1738,7 @@
 	ret = strftime(out, test->vec[i].max-1, test->vec[i].fmt, test->tms);
 	if(ret != 0)  {
 	    errr++;
-	    fprintf(stderr,
+	    fiprintf(stderr,
 		"ERROR:  return %d != %d expected for List[%d].vec[%d]\n",
 						ret, 0, l, i);
 	    }
@@ -1747,7 +1748,7 @@
 	 * works.)  */
 	if(strncmp(out, test->vec[i].out, test->vec[i].max-1-1))  {
 	    erro++;
-	    fprintf(stderr,
+	    fiprintf(stderr,
 		"ERROR:  \"%"SFLG"s\" != \"%"SFLG"s\" expected for List[%d].vec[%d]\n",
 						out, test->vec[i].out, l, i);
 	    }
@@ -1762,13 +1763,13 @@
 	ret = strftime(out, test->vec[i].max, test->vec[i].fmt, test->tms);
 	if(ret != test->vec[i].ret)  {
 	    errr++;
-	    fprintf(stderr,
+	    fiprintf(stderr,
 		"ERROR:  return %d != %d expected for ListYr[%d].vec[%d]\n",
 						ret, test->vec[i].ret, l, i);
 	    }
 	if(strncmp(out, test->vec[i].out, test->vec[i].max-1))  {
 	    erro++;
-	    fprintf(stderr,
+	    fiprintf(stderr,
 		"ERROR:  \"%"SFLG"s\" != \"%"SFLG"s\" expected for ListYr[%d].vec[%d]\n",
 						out, test->vec[i].out, l, i);
 	    }
@@ -1777,10 +1778,10 @@
  
 #define STRIZE(f)	#f
 #define NAME(f)	STRIZE(f)
-printf(NAME(strftime) "() test ");
-if(errr || erro)  printf("FAILED %d/%d of", errr, erro);
-  else    printf("passed");
-printf(" %d test cases.\n", tot);
+iprintf(NAME(strftime) "() test ");
+if(errr || erro)  iprintf("FAILED %d/%d of", errr, erro);
+  else    iprintf("passed");
+iprintf(" %d test cases.\n", tot);
  
 return(errr || erro);
 }
diff -u newlib/libc/time.original/tzset_r.c newlib/libc/time/tzset_r.c
--- newlib/libc/time.original/tzset_r.c	2008-10-06 21:21:29.000000000 +0200
+++ newlib/libc/time/tzset_r.c	2011-05-23 13:17:42.000000000 +0200
@@ -49,7 +49,7 @@
   if (*tzenv == ':')
     ++tzenv;  
 
-  if (sscanf (tzenv, "%10[^0-9,+-]%n", __tzname_std, &n) <= 0)
+  if (siscanf (tzenv, "%10[^0-9,+-]%n", __tzname_std, &n) <= 0)
     {
       TZ_UNLOCK;
       return;
@@ -69,7 +69,7 @@
   mm = 0;
   ss = 0;
  
-  if (sscanf (tzenv, "%hu%n:%hu%n:%hu%n", &hh, &n, &mm, &n, &ss, &n) < 1)
+  if (siscanf (tzenv, "%hu%n:%hu%n:%hu%n", &hh, &n, &mm, &n, &ss, &n) < 1)
     {
       TZ_UNLOCK;
       return;
@@ -79,7 +79,7 @@
   _tzname[0] = __tzname_std;
   tzenv += n;
   
-  if (sscanf (tzenv, "%10[^0-9,+-]%n", __tzname_dst, &n) <= 0)
+  if (siscanf (tzenv, "%10[^0-9,+-]%n", __tzname_dst, &n) <= 0)
     {
       _tzname[1] = _tzname[0];
       TZ_UNLOCK;
@@ -105,7 +105,7 @@
   ss = 0;
   
   n  = 0;
-  if (sscanf (tzenv, "%hu%n:%hu%n:%hu%n", &hh, &n, &mm, &n, &ss, &n) <= 0)
+  if (siscanf (tzenv, "%hu%n:%hu%n:%hu%n", &hh, &n, &mm, &n, &ss, &n) <= 0)
     tz->__tzrule[1].offset = tz->__tzrule[0].offset - 3600;
   else
     tz->__tzrule[1].offset = sign * (ss + SECSPERMIN * mm + SECSPERHOUR * hh);
@@ -119,7 +119,7 @@
 
       if (*tzenv == 'M')
 	{
-	  if (sscanf (tzenv, "M%hu%n.%hu%n.%hu%n", &m, &n, &w, &n, &d, &n) != 3 ||
+	  if (siscanf (tzenv, "M%hu%n.%hu%n.%hu%n", &m, &n, &w, &n, &d, &n) != 3 ||
 	      m < 1 || m > 12 || w < 1 || w > 5 || d > 6)
 	    {
 	      TZ_UNLOCK;
@@ -182,7 +182,7 @@
       n = 0;
       
       if (*tzenv == '/')
-	sscanf (tzenv, "/%hu%n:%hu%n:%hu%n", &hh, &n, &mm, &n, &ss, &n);
+	siscanf (tzenv, "/%hu%n:%hu%n:%hu%n", &hh, &n, &mm, &n, &ss, &n);
 
       tz->__tzrule[i].s = ss + SECSPERMIN * mm + SECSPERHOUR  * hh;
       
